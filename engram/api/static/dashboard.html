<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engram Memory Visualizer</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<style>
:root {
  --bg: #0a0a1a;
  --panel: rgba(20, 20, 50, 0.6);
  --border: rgba(124, 58, 237, 0.3);
  --purple: #7c3aed;
  --cyan: #06b6d4;
  --gold: #f59e0b;
  --text: #e2e8f0;
  --text-dim: #94a3b8;
  --radius: 12px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Inter', -apple-system, system-ui, sans-serif;
  overflow-x: hidden;
  min-height: 100vh;
}

#starfield {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  z-index: 0; pointer-events: none;
}

.app { position: relative; z-index: 1; max-width: 1400px; margin: 0 auto; padding: 20px; }

.glass {
  background: var(--panel);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: var(--radius);
}

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 24px; margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
}

.logo { display: flex; align-items: center; gap: 10px; }
.logo svg { width: 32px; height: 32px; }
.logo h1 { font-size: 1.3rem; font-weight: 700; background: linear-gradient(135deg, var(--purple), var(--cyan)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

.tabs { display: flex; gap: 4px; flex-wrap: wrap; }
.tab-btn {
  padding: 8px 16px; border: 1px solid transparent; border-radius: 8px;
  background: transparent; color: var(--text-dim); cursor: pointer;
  font-size: 0.85rem; font-weight: 500; transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
}
.tab-btn:hover { color: var(--text); background: rgba(124,58,237,0.15); }
.tab-btn.active {
  color: #fff; background: linear-gradient(135deg, var(--purple), rgba(6,182,212,0.4));
  border-color: var(--purple); box-shadow: 0 0 20px rgba(124,58,237,0.3);
}

section { display: none; animation: fadeIn 0.4s cubic-bezier(0.4,0,0.2,1); }
section.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

/* Overview */
.stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
.stat-card { padding: 20px; text-align: center; }
.stat-value {
  font-size: 2.2rem; font-weight: 800;
  background: linear-gradient(135deg, var(--purple), var(--cyan));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.stat-label { font-size: 0.8rem; color: var(--text-dim); margin-top: 4px; text-transform: uppercase; letter-spacing: 1px; }

.charts-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 20px; }
.chart-panel { padding: 16px; }
.chart-panel h3 { font-size: 0.9rem; color: var(--text-dim); margin-bottom: 12px; }
.chart-panel canvas { width: 100% !important; max-height: 220px; }

/* Constellation */
#constellation-svg { width: 100%; height: 600px; border-radius: var(--radius); }
.constellation-panel { padding: 0; overflow: hidden; position: relative; }
.constellation-panel .controls { position: absolute; top: 12px; right: 12px; z-index: 2; display: flex; gap: 8px; }
.constellation-panel .controls button {
  padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--panel); color: var(--text); cursor: pointer; font-size: 0.8rem;
  backdrop-filter: blur(8px);
}
.constellation-panel .controls button:hover { border-color: var(--purple); }
.tooltip {
  position: absolute; padding: 10px 14px; border-radius: 8px;
  background: rgba(10,10,26,0.95); border: 1px solid var(--purple);
  color: var(--text); font-size: 0.8rem; pointer-events: none;
  max-width: 300px; z-index: 10; backdrop-filter: blur(8px);
  box-shadow: 0 0 20px rgba(124,58,237,0.3);
}
.tooltip .layer-badge {
  display: inline-block; padding: 2px 6px; border-radius: 4px;
  font-size: 0.7rem; font-weight: 600; margin-left: 6px;
}
.tooltip .sml { background: rgba(6,182,212,0.2); color: var(--cyan); }
.tooltip .lml { background: rgba(245,158,11,0.2); color: var(--gold); }

/* Scenes */
.timeline { display: flex; flex-direction: column; gap: 12px; padding: 16px; }
.scene-card { padding: 16px; cursor: pointer; transition: all 0.3s; }
.scene-card:hover { border-color: var(--purple); box-shadow: 0 0 20px rgba(124,58,237,0.2); }
.scene-card.expanded { border-color: var(--cyan); }
.scene-header { display: flex; justify-content: space-between; align-items: center; }
.scene-title { font-weight: 600; font-size: 0.95rem; }
.scene-time { font-size: 0.75rem; color: var(--text-dim); }
.scene-topic { font-size: 0.8rem; color: var(--cyan); margin-top: 4px; }
.scene-summary { font-size: 0.85rem; color: var(--text-dim); margin-top: 8px; line-height: 1.5; }
.scene-details { margin-top: 12px; display: none; }
.scene-card.expanded .scene-details { display: block; }
.scene-meta { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 8px; }
.scene-meta span { font-size: 0.75rem; color: var(--text-dim); }

/* Profiles */
.profiles-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px; padding: 16px; }
.profile-card { padding: 16px; cursor: pointer; transition: all 0.3s; }
.profile-card:hover { border-color: var(--purple); box-shadow: 0 0 20px rgba(124,58,237,0.2); }
.profile-card.self-profile { border-color: var(--gold); box-shadow: 0 0 15px rgba(245,158,11,0.15); }
.profile-name { font-size: 1.1rem; font-weight: 700; }
.profile-type {
  display: inline-block; padding: 2px 8px; border-radius: 4px;
  font-size: 0.7rem; font-weight: 600; margin-left: 8px;
}
.type-self { background: rgba(245,158,11,0.2); color: var(--gold); }
.type-contact { background: rgba(6,182,212,0.2); color: var(--cyan); }
.type-entity { background: rgba(124,58,237,0.2); color: var(--purple); }
.profile-narrative { font-size: 0.85rem; color: var(--text-dim); margin-top: 8px; line-height: 1.5; }
.profile-facts { margin-top: 10px; }
.profile-facts li { font-size: 0.8rem; color: var(--text-dim); margin: 4px 0; list-style: none; padding-left: 12px; position: relative; }
.profile-facts li::before { content: ""; position: absolute; left: 0; top: 8px; width: 4px; height: 4px; border-radius: 50%; background: var(--cyan); }
.profile-details { display: none; margin-top: 12px; }
.profile-card.expanded .profile-details { display: block; }

/* Categories */
.category-tree { padding: 16px; }
.cat-node { margin-left: 20px; margin-bottom: 6px; }
.cat-node.root { margin-left: 0; }
.cat-header {
  display: flex; align-items: center; gap: 8px; padding: 8px 12px;
  border-radius: 8px; cursor: pointer; transition: background 0.2s;
}
.cat-header:hover { background: rgba(124,58,237,0.1); }
.cat-toggle { width: 16px; font-size: 0.7rem; color: var(--text-dim); transition: transform 0.2s; }
.cat-toggle.open { transform: rotate(90deg); }
.cat-name { font-weight: 600; font-size: 0.9rem; }
.cat-count { font-size: 0.75rem; color: var(--text-dim); }
.strength-bar { flex: 1; max-width: 120px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
.strength-fill { height: 100%; border-radius: 2px; background: linear-gradient(90deg, var(--purple), var(--cyan)); transition: width 0.5s; }
.cat-children { overflow: hidden; transition: max-height 0.3s ease; }

/* Stream */
.stream-controls { display: flex; gap: 8px; padding: 16px; flex-wrap: wrap; }
.stream-filter {
  padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: transparent; color: var(--text-dim); cursor: pointer; font-size: 0.8rem;
}
.stream-filter.active { color: #fff; border-color: var(--purple); background: rgba(124,58,237,0.2); }
.memory-list { padding: 0 16px 16px; }
.memory-item { padding: 12px 16px; margin-bottom: 8px; display: flex; gap: 12px; align-items: flex-start; }
.memory-strength-col { width: 40px; flex-shrink: 0; text-align: center; }
.memory-strength-ring {
  width: 36px; height: 36px; border-radius: 50%; position: relative;
  display: flex; align-items: center; justify-content: center;
}
.memory-strength-ring span { font-size: 0.65rem; font-weight: 700; }
.memory-content { flex: 1; }
.memory-text { font-size: 0.85rem; line-height: 1.5; }
.memory-meta { display: flex; gap: 8px; margin-top: 6px; flex-wrap: wrap; align-items: center; }
.layer-pill {
  display: inline-block; padding: 1px 6px; border-radius: 4px;
  font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
}
.layer-sml { background: rgba(6,182,212,0.2); color: var(--cyan); }
.layer-lml { background: rgba(245,158,11,0.2); color: var(--gold); }
.cat-pill { padding: 1px 6px; border-radius: 4px; background: rgba(124,58,237,0.15); color: var(--purple); font-size: 0.65rem; }
.memory-time { font-size: 0.7rem; color: var(--text-dim); }

.empty-state { text-align: center; padding: 60px 20px; color: var(--text-dim); }
.empty-state p { font-size: 1rem; margin-bottom: 8px; }
.empty-state small { font-size: 0.8rem; opacity: 0.6; }

.loading { text-align: center; padding: 40px; color: var(--text-dim); }
.loading::after { content: ""; display: inline-block; width: 16px; height: 16px; border: 2px solid var(--purple); border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; margin-left: 8px; vertical-align: middle; }
@keyframes spin { to { transform: rotate(360deg); } }

@keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }

@media (max-width: 768px) {
  .charts-row { grid-template-columns: 1fr; }
  .stats-grid { grid-template-columns: repeat(2, 1fr); }
  header { flex-direction: column; align-items: flex-start; }
}
</style>
</head>
<body>

<canvas id="starfield"></canvas>

<div class="app">
  <header class="glass">
    <div class="logo">
      <svg viewBox="0 0 32 32" fill="none">
        <circle cx="16" cy="16" r="14" stroke="url(#g1)" stroke-width="2"/>
        <circle cx="16" cy="16" r="4" fill="url(#g1)"/>
        <circle cx="8" cy="10" r="2" fill="#06b6d4" opacity="0.8"/>
        <circle cx="24" cy="12" r="2" fill="#f59e0b" opacity="0.8"/>
        <circle cx="12" cy="24" r="2" fill="#7c3aed" opacity="0.8"/>
        <line x1="16" y1="16" x2="8" y2="10" stroke="#06b6d4" stroke-width="0.5" opacity="0.5"/>
        <line x1="16" y1="16" x2="24" y2="12" stroke="#f59e0b" stroke-width="0.5" opacity="0.5"/>
        <line x1="16" y1="16" x2="12" y2="24" stroke="#7c3aed" stroke-width="0.5" opacity="0.5"/>
        <defs><linearGradient id="g1" x1="0" y1="0" x2="32" y2="32"><stop stop-color="#7c3aed"/><stop offset="1" stop-color="#06b6d4"/></linearGradient></defs>
      </svg>
      <h1>Engram Memory Visualizer</h1>
    </div>
    <nav class="tabs">
      <button class="tab-btn active" data-tab="overview">Overview</button>
      <button class="tab-btn" data-tab="constellation">Constellation</button>
      <button class="tab-btn" data-tab="scenes">Scenes</button>
      <button class="tab-btn" data-tab="profiles">Profiles</button>
      <button class="tab-btn" data-tab="categories">Categories</button>
      <button class="tab-btn" data-tab="stream">Stream</button>
    </nav>
  </header>

  <main>
    <!-- OVERVIEW -->
    <section id="overview" class="active">
      <div class="stats-grid" id="stats-cards"></div>
      <div class="charts-row">
        <div class="chart-panel glass"><h3>Memory Layers</h3><canvas id="donut-chart"></canvas></div>
        <div class="chart-panel glass"><h3>Top Categories</h3><canvas id="bar-chart"></canvas></div>
        <div class="chart-panel glass"><h3>Decay History</h3><canvas id="sparkline-chart"></canvas></div>
      </div>
    </section>

    <!-- CONSTELLATION -->
    <section id="constellation">
      <div class="constellation-panel glass">
        <div class="controls">
          <button onclick="resetConstellation()">Reset View</button>
        </div>
        <svg id="constellation-svg"></svg>
      </div>
    </section>

    <!-- SCENES -->
    <section id="scenes">
      <div class="timeline" id="scene-list"></div>
    </section>

    <!-- PROFILES -->
    <section id="profiles">
      <div class="profiles-grid" id="profile-list"></div>
    </section>

    <!-- CATEGORIES -->
    <section id="categories">
      <div class="category-tree" id="cat-tree"></div>
    </section>

    <!-- STREAM -->
    <section id="stream">
      <div class="stream-controls" id="stream-filters"></div>
      <div class="memory-list" id="memory-stream"></div>
    </section>
  </main>
</div>

<div class="tooltip" id="tooltip" style="display:none;"></div>

<script>
// =========================================================================
// API helpers
// =========================================================================
const API = '/v1';
async function api(path) {
  try {
    const r = await fetch(API + path);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  } catch (e) { console.error('API error:', path, e); return null; }
}

// =========================================================================
// Starfield
// =========================================================================
(function initStarfield() {
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d');
  let w, h, stars = [];

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
  }

  function init() {
    resize();
    stars = Array.from({ length: 200 }, () => ({
      x: Math.random() * w, y: Math.random() * h,
      r: Math.random() * 1.5 + 0.3,
      dx: (Math.random() - 0.5) * 0.15,
      dy: (Math.random() - 0.5) * 0.15,
      a: Math.random(),
      da: (Math.random() - 0.5) * 0.01,
    }));
  }

  function draw() {
    ctx.clearRect(0, 0, w, h);
    for (const s of stars) {
      s.x += s.dx; s.y += s.dy; s.a += s.da;
      if (s.a > 1) s.da = -Math.abs(s.da);
      if (s.a < 0.2) s.da = Math.abs(s.da);
      if (s.x < 0) s.x = w; if (s.x > w) s.x = 0;
      if (s.y < 0) s.y = h; if (s.y > h) s.y = 0;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(180, 180, 220, ${s.a * 0.6})`;
      ctx.fill();
    }
    requestAnimationFrame(draw);
  }

  window.addEventListener('resize', resize);
  init(); draw();
})();

// =========================================================================
// Tab switching
// =========================================================================
const tabBtns = document.querySelectorAll('.tab-btn');
const sections = document.querySelectorAll('main > section');
const loaded = new Set(['overview']);

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    tabBtns.forEach(b => b.classList.remove('active'));
    sections.forEach(s => s.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.dataset.tab;
    document.getElementById(tab).classList.add('active');
    if (!loaded.has(tab)) { loaded.add(tab); loaders[tab](); }
  });
});

// =========================================================================
// Overview
// =========================================================================
async function loadOverview() {
  const [statsData, catData, decayData] = await Promise.all([
    api('/stats'), api('/categories'), api('/decay-log'),
  ]);

  // Stat cards
  const stats = statsData || {};
  const cards = [
    { value: stats.total_memories || 0, label: 'Total Memories' },
    { value: stats.sml_count || 0, label: 'Short-Term (SML)' },
    { value: stats.lml_count || 0, label: 'Long-Term (LML)' },
    { value: Object.keys(stats.categories || {}).length, label: 'Categories' },
  ];
  document.getElementById('stats-cards').innerHTML = cards.map(c =>
    `<div class="stat-card glass"><div class="stat-value">${c.value}</div><div class="stat-label">${c.label}</div></div>`
  ).join('');

  // Donut chart
  const donutCtx = document.getElementById('donut-chart').getContext('2d');
  new Chart(donutCtx, {
    type: 'doughnut',
    data: {
      labels: ['SML', 'LML'],
      datasets: [{ data: [stats.sml_count || 0, stats.lml_count || 0], backgroundColor: ['#06b6d4', '#f59e0b'], borderWidth: 0 }],
    },
    options: { responsive: true, plugins: { legend: { labels: { color: '#94a3b8' } } } },
  });

  // Bar chart
  const cats = stats.categories || {};
  const sortedCats = Object.entries(cats).sort((a, b) => b[1] - a[1]).slice(0, 8);
  const barCtx = document.getElementById('bar-chart').getContext('2d');
  new Chart(barCtx, {
    type: 'bar',
    data: {
      labels: sortedCats.map(c => c[0].slice(0, 15)),
      datasets: [{ data: sortedCats.map(c => c[1]), backgroundColor: '#7c3aed', borderRadius: 4 }],
    },
    options: {
      responsive: true, indexAxis: 'y',
      plugins: { legend: { display: false } },
      scales: { x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' } }, y: { ticks: { color: '#94a3b8' }, grid: { display: false } } },
    },
  });

  // Sparkline
  const entries = (decayData?.entries || []).reverse();
  const sparkCtx = document.getElementById('sparkline-chart').getContext('2d');
  new Chart(sparkCtx, {
    type: 'line',
    data: {
      labels: entries.map((e, i) => i + 1),
      datasets: [
        { label: 'Decayed', data: entries.map(e => e.memories_decayed || 0), borderColor: '#7c3aed', tension: 0.4, pointRadius: 2, borderWidth: 2 },
        { label: 'Forgotten', data: entries.map(e => e.memories_forgotten || 0), borderColor: '#ef4444', tension: 0.4, pointRadius: 2, borderWidth: 2 },
        { label: 'Promoted', data: entries.map(e => e.memories_promoted || 0), borderColor: '#f59e0b', tension: 0.4, pointRadius: 2, borderWidth: 2 },
      ],
    },
    options: {
      responsive: true,
      plugins: { legend: { labels: { color: '#94a3b8', boxWidth: 12 } } },
      scales: { x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' } }, y: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' } } },
    },
  });
}

// =========================================================================
// Constellation
// =========================================================================
let simulation;
function resetConstellation() {
  if (simulation) simulation.alpha(1).restart();
}

async function loadConstellation() {
  const data = await api('/dashboard/constellation');
  if (!data || !data.nodes.length) {
    document.querySelector('.constellation-panel').innerHTML = '<div class="empty-state"><p>No memories yet</p><small>Add some memories to see the constellation</small></div>';
    return;
  }

  const svg = d3.select('#constellation-svg');
  const container = svg.node().parentElement;
  const width = container.clientWidth;
  const height = 600;
  svg.attr('viewBox', `0 0 ${width} ${height}`);

  const tooltip = document.getElementById('tooltip');

  // Deduplicate edges
  const edgeKey = e => [e.source, e.target].sort().join('|') + e.type;
  const uniqueEdges = [...new Map(data.edges.map(e => [edgeKey(e), e])).values()];

  const nodeMap = new Map(data.nodes.map(n => [n.id, n]));

  // Filter edges to only include nodes we have
  const edges = uniqueEdges.filter(e => nodeMap.has(e.source) && nodeMap.has(e.target));

  const link = svg.append('g')
    .selectAll('line')
    .data(edges)
    .join('line')
    .attr('stroke', d => d.type === 'scene' ? 'rgba(6,182,212,0.2)' : 'rgba(245,158,11,0.2)')
    .attr('stroke-width', 1)
    .attr('stroke-dasharray', d => d.type === 'profile' ? '4,4' : 'none');

  const node = svg.append('g')
    .selectAll('circle')
    .data(data.nodes)
    .join('circle')
    .attr('r', d => Math.max(4, d.strength * 12))
    .attr('fill', d => d.layer === 'lml' ? '#f59e0b' : '#06b6d4')
    .attr('opacity', 0.8)
    .style('filter', d => `drop-shadow(0 0 ${d.strength * 6}px ${d.layer === 'lml' ? '#f59e0b' : '#06b6d4'})`)
    .style('cursor', 'pointer')
    .call(d3.drag()
      .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
      .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
      .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
    );

  // Hover tooltips
  node.on('mouseover', (e, d) => {
    const cats = (d.categories || []).join(', ') || 'none';
    tooltip.innerHTML = `<strong>${d.memory}</strong><br><span class="layer-badge ${d.layer}">${d.layer.toUpperCase()}</span> Strength: ${(d.strength * 100).toFixed(0)}%<br><small>Categories: ${cats}</small>`;
    tooltip.style.display = 'block';
  })
  .on('mousemove', e => {
    tooltip.style.left = (e.pageX + 12) + 'px';
    tooltip.style.top = (e.pageY - 10) + 'px';
  })
  .on('mouseout', () => { tooltip.style.display = 'none'; });

  // Click to focus
  let focused = null;
  node.on('click', (e, d) => {
    if (focused === d.id) {
      focused = null;
      node.attr('opacity', 0.8);
      link.attr('opacity', 1);
    } else {
      focused = d.id;
      const neighbors = new Set();
      neighbors.add(d.id);
      edges.forEach(edge => {
        const src = typeof edge.source === 'object' ? edge.source.id : edge.source;
        const tgt = typeof edge.target === 'object' ? edge.target.id : edge.target;
        if (src === d.id) neighbors.add(tgt);
        if (tgt === d.id) neighbors.add(src);
      });
      node.attr('opacity', n => neighbors.has(n.id) ? 1 : 0.1);
      link.attr('opacity', l => {
        const src = typeof l.source === 'object' ? l.source.id : l.source;
        const tgt = typeof l.target === 'object' ? l.target.id : l.target;
        return (src === d.id || tgt === d.id) ? 1 : 0.05;
      });
    }
  });

  simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(edges).id(d => d.id).distance(80))
    .force('charge', d3.forceManyBody().strength(-120))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(d => d.strength * 14 + 4))
    .on('tick', () => {
      link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
      node.attr('cx', d => d.x = Math.max(10, Math.min(width - 10, d.x)))
          .attr('cy', d => d.y = Math.max(10, Math.min(height - 10, d.y)));
    });
}

// =========================================================================
// Scenes
// =========================================================================
async function loadScenes() {
  const data = await api('/scenes');
  const container = document.getElementById('scene-list');
  const scenes = data?.scenes || [];

  if (!scenes.length) {
    container.innerHTML = '<div class="empty-state"><p>No scenes recorded</p><small>Scenes are created as episodic memory groups</small></div>';
    return;
  }

  container.innerHTML = scenes.map(s => {
    const time = s.start_time ? new Date(s.start_time).toLocaleString() : 'Unknown';
    const memCount = (s.memory_ids || []).length;
    return `
      <div class="scene-card glass" onclick="this.classList.toggle('expanded')">
        <div class="scene-header">
          <span class="scene-title">${escHtml(s.title || 'Untitled Scene')}</span>
          <span class="scene-time">${time}</span>
        </div>
        ${s.topic ? `<div class="scene-topic">${escHtml(s.topic)}</div>` : ''}
        ${s.summary ? `<div class="scene-summary">${escHtml(s.summary)}</div>` : ''}
        <div class="scene-details">
          <div class="scene-meta">
            <span>Memories: ${memCount}</span>
            ${s.location ? `<span>Location: ${escHtml(s.location)}</span>` : ''}
            <span>Strength: ${((s.strength || 1) * 100).toFixed(0)}%</span>
          </div>
        </div>
      </div>`;
  }).join('');
}

// =========================================================================
// Profiles
// =========================================================================
async function loadProfiles() {
  const data = await api('/profiles');
  const container = document.getElementById('profile-list');
  const profiles = data?.profiles || [];

  if (!profiles.length) {
    container.innerHTML = '<div class="empty-state"><p>No profiles detected</p><small>Profiles are extracted from memory content</small></div>';
    return;
  }

  container.innerHTML = profiles.map(p => {
    const isSelf = p.profile_type === 'self';
    const typeClass = p.profile_type === 'self' ? 'type-self' : p.profile_type === 'entity' ? 'type-entity' : 'type-contact';
    const facts = (p.facts || []).slice(0, 5);
    return `
      <div class="profile-card glass ${isSelf ? 'self-profile' : ''}" onclick="this.classList.toggle('expanded')">
        <div>
          <span class="profile-name">${escHtml(p.name)}</span>
          <span class="profile-type ${typeClass}">${p.profile_type}</span>
        </div>
        ${p.narrative ? `<div class="profile-narrative">${escHtml(p.narrative.slice(0, 150))}${p.narrative.length > 150 ? '...' : ''}</div>` : ''}
        <div class="profile-details">
          ${facts.length ? `<ul class="profile-facts">${facts.map(f => `<li>${escHtml(String(f))}</li>`).join('')}</ul>` : ''}
          ${p.sentiment ? `<div style="margin-top:8px;font-size:0.8rem;color:var(--text-dim)">Sentiment: ${escHtml(p.sentiment)}</div>` : ''}
        </div>
      </div>`;
  }).join('');
}

// =========================================================================
// Categories
// =========================================================================
async function loadCategories() {
  const data = await api('/categories/tree');
  const container = document.getElementById('cat-tree');
  const tree = data?.tree || [];

  if (!tree.length) {
    // Fallback to flat list
    const flatData = await api('/categories');
    const cats = flatData?.categories || [];
    if (!cats.length) {
      container.innerHTML = '<div class="empty-state"><p>No categories yet</p><small>Categories emerge as memories are added</small></div>';
      return;
    }
    container.innerHTML = cats.map(c => renderCatNode(c, true)).join('');
    return;
  }

  container.innerHTML = tree.map(n => renderCatNode(n, true)).join('');
}

function renderCatNode(node, isRoot) {
  const children = node.children || [];
  const hasChildren = children.length > 0;
  const strength = node.strength || 0;
  const pct = Math.min(100, strength * 100);
  return `
    <div class="cat-node ${isRoot ? 'root' : ''}">
      <div class="cat-header" onclick="this.querySelector('.cat-toggle')?.classList.toggle('open'); const c=this.nextElementSibling; if(c) c.style.maxHeight = c.style.maxHeight ? null : c.scrollHeight+'px';">
        ${hasChildren ? '<span class="cat-toggle">&#9654;</span>' : '<span style="width:16px"></span>'}
        <span class="cat-name">${escHtml(node.name || node.id || 'unknown')}</span>
        <span class="cat-count">(${node.memory_count || 0})</span>
        <div class="strength-bar"><div class="strength-fill" style="width:${pct}%"></div></div>
      </div>
      ${hasChildren ? `<div class="cat-children" style="max-height:0;overflow:hidden">${children.map(c => renderCatNode(c, false)).join('')}</div>` : ''}
    </div>`;
}

// =========================================================================
// Stream
// =========================================================================
let streamOffset = 0;
let streamLayer = null;
let allMemories = [];

async function loadStream() {
  streamOffset = 0;
  streamLayer = null;
  allMemories = [];
  await fetchStream();
  renderStreamFilters();
}

async function fetchStream() {
  const params = new URLSearchParams({ limit: '200' });
  if (streamLayer) params.set('layer', streamLayer);
  const data = await api('/memories?' + params);
  allMemories = data?.memories || [];
  renderStream();
}

function renderStreamFilters() {
  const container = document.getElementById('stream-filters');
  container.innerHTML = ['All', 'SML', 'LML'].map(f => {
    const val = f === 'All' ? null : f.toLowerCase();
    const active = streamLayer === val;
    return `<button class="stream-filter ${active ? 'active' : ''}" onclick="setStreamFilter(${val ? `'${val}'` : 'null'})">${f}</button>`;
  }).join('');
}

function setStreamFilter(layer) {
  streamLayer = layer;
  renderStreamFilters();
  fetchStream();
}

function renderStream() {
  const container = document.getElementById('memory-stream');
  if (!allMemories.length) {
    container.innerHTML = '<div class="empty-state"><p>No memories found</p></div>';
    return;
  }

  container.innerHTML = allMemories.map(m => {
    const strength = m.strength || 0;
    const pct = (strength * 100).toFixed(0);
    const layer = m.layer || 'sml';
    const color = layer === 'lml' ? 'var(--gold)' : 'var(--cyan)';
    const cats = (m.categories || []).slice(0, 3);
    const time = m.created_at ? new Date(m.created_at).toLocaleString() : '';
    return `
      <div class="memory-item glass">
        <div class="memory-strength-col">
          <div class="memory-strength-ring" style="border:2px solid ${color}">
            <span style="color:${color}">${pct}</span>
          </div>
        </div>
        <div class="memory-content">
          <div class="memory-text">${escHtml((m.memory || '').slice(0, 200))}</div>
          <div class="memory-meta">
            <span class="layer-pill layer-${layer}">${layer}</span>
            ${cats.map(c => `<span class="cat-pill">${escHtml(String(c))}</span>`).join('')}
            <span class="memory-time">${time}</span>
          </div>
        </div>
      </div>`;
  }).join('');
}

// =========================================================================
// Util
// =========================================================================
function escHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

// =========================================================================
// Loaders map & init
// =========================================================================
const loaders = {
  overview: loadOverview,
  constellation: loadConstellation,
  scenes: loadScenes,
  profiles: loadProfiles,
  categories: loadCategories,
  stream: loadStream,
};

loadOverview();
</script>
</body>
</html>
